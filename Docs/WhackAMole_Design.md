# WhackAMole - 需求与技术设计文档 v2.1

## 文档信息
- **版本**: 2.1
- **最后更新**: 2026-01-22
- **性质**: 需求与技术设计（不包含实施规划/里程碑/进度）

---

## 目录

1. [产品愿景](#1-产品愿景)
2. [需求与约束](#2-需求与约束)
3. [系统架构](#3-系统架构)
4. [数据模型与状态快照](#4-数据模型与状态快照)
5. [APL 语言与编译执行机制](#5-apl-语言与编译执行机制)
6. [决策引擎与预测机制](#6-决策引擎与预测机制)
7. [UI 与交互设计](#7-ui-与交互设计)
8. [配置体系与配置交换](#8-配置体系与配置交换)
9. [性能、可靠性与可观测性](#9-性能可靠性与可观测性)
10. [兼容性与本地化](#10-兼容性与本地化)
11. [附录](#11-附录)

---

## 1. 产品愿景

WhackAMole 是一个面向 **WoW WotLK 3.3.5a** 的可视化输出循环辅助插件。

### 1.1 核心理念

**Show, Don't Tell（展示位置，而非告知技能）**：
- 插件输出的是“应该按哪个键位/槽位”，而不是“下一招是什么”。
- 目标是强化肌肉记忆与键位一致性，降低对图标队列的依赖。

### 1.2 目标用户

- 学习者：通过稳定的视觉反馈掌握循环。
- 理论派：基于优先级列表验证逻辑并分享。
- 键盘党：以键位为中心而非鼠标点技能。

---

## 2. 需求与约束

### 2.1 功能性需求

- 动作提示：将“推荐动作”映射为一个或多个可高亮的网格槽位。
- APL 表达：支持 SimC 风格优先级列表，动作可带条件表达式。
- 预测提示：可选地在“当前决策”之外给出“下一步预测”。
- 配置管理：支持内置配置与用户配置；支持切换；支持导入/导出。
- 音频提示：可选的动作语音/音效提示，并具备节流避免重复播报。
- 调试能力：提供命令行查看状态、验证条件表达式、输出性能统计。

### 2.2 非功能性需求

- 性能：战斗中持续运行，平均帧耗时目标 $< 3\text{ms}$，峰值应可控。
- 稳定性：任何单条 APL 条件错误不应导致插件崩溃；错误需隔离与可追踪。
- 可移植性：APL/配置应易于分享与跨角色复用（在职业/专精约束内）。
- 可理解性：用户能在不学习 Lua 的前提下写出可用的优先级逻辑。

### 2.3 约束与假设

- 平台：WotLK 3.3.5a（含私服实现差异）。
- 数据源：以 WoW API 状态为准，所有“推荐”仅基于当前快照推断。
- SpellID 优先：在多语言环境下，SpellID 比技能名更稳定。

---

## 3. 系统架构

### 3.1 分层与职责

```
用户层：玩家输入 / 配置导入 / UI交互 (UI/Grid, UI/Options)
  ↓
核心层 (Core)：
  - Lifecycle: 插件生命周期与事件钩子
  - ProfileLoader: 配置加载与 AP 预编译
  - EventHandler: 战斗事件监听与节流控制
  - UpdateLoop: 主循环调度
  ↓
业务领域层 (Classes):
  - Registry: 专精检测与模块注册
  - Spells: 职业技能书定义
  ↓
引擎层 (Engine)：
  - State: 状态管理与数据快照 (Init, AuraTracking, StateReset)
  - SimCParser: 词法分析、Lua 代码生成与缓存
  - APLExecutor: 优先级列表执行机
  ↓
表现层：网格渲染、高亮与动画、音频提示
```

### 3.2 关键数据流

- 初始化：加载配置 → 识别职业/专精 → 载入动作与 APL → 编译条件 → 初始化 UI。
- 每帧：生成状态快照 → 执行 APL 决策 → 输出推荐动作 → 映射槽位 → 更新高亮/音频。
- 导入：字符串解码 → 结构校验 → 写入配置 → 重新编译 APL → 刷新 UI。

---

## 4. 数据模型与状态快照

### 4.1 设计目标

- 将“瞬时游戏态”封装成只读快照，避免跨模块重复调用 API。
- 为 APL 条件提供一致的字段访问方式（buff/cooldown/resource 等）。
- 支持“虚拟时间”推进以做预测（不直接改变真实游戏状态）。

### 4.2 快照的核心视图

快照（Context）提供以下逻辑视图（字段命名为概念描述，具体实现可调整）：
- 时间：now、combat_time。
- 玩家：生命/资源、GCD、施法（读条/引导/结束时间）。
- 目标：存在性、生命信息、施法状态、距离（若可用）。
- Buff/Debuff：up/down、层数、剩余时间、是否自身施加。
- Cooldown：ready/remains/charges（视技能类型而定）。
- Talent：是否点出、等级（或布尔）。

### 4.3 一致性与更新策略

- **惰性求值 (Lazy Evaluation)**：利用 Lua 元表 (`metatable`) 的 `__index` 机制，状态字段（如技能CD、Buff状态）仅在 APL 逻辑实际访问时才调用 WoW API 获取。
- **帧内缓存**：在同一帧内的多次访问直接返回首次获取的缓存值，帧结束时（`StateReset`）清理缓存。
- **对象池**：复用临时表结构，降低由高频创建/销毁对象引起的 GC 抖动。

---

## 5. APL 语言与编译执行机制

### 5.1 APL 的定位

- APL 是面向用户的“优先级规则语言”，表达“先检查哪条规则”。
- APL 不暴露 Lua 脚本能力；目标是可读、可移植、可约束。

### 5.2 语法能力（子集）

- 动作行：`action` + 可选 `if=<condition>`。
- 条件表达式：布尔逻辑、比较、括号优先级。
- 领域对象：buff/debuff/cooldown/resource/target/player/talent 等。

### 5.3 编译与运行时语义

- **解析与代码生成**：`SimCParser` 对 APL 文本进行词法分析，直接转换为等效的 Lua 代码字符串。
- **动态编译**：利用 Lua 的 `loadstring` 将生成的代码编译为可执行的匿名函数（Predicate）。
- **函数缓存**：编译后的函数在 `SimCParser` 中以弱引用表形式缓存，相同的条件字符串直接复用已编译的函数，避免重复解析开销。
- **执行阶段**：`APLExecutor` 接收编译好的 APL 列表，按序传入当前 `State` 对象执行，返回第一条满足条件的动作。

### 5.4 错误处理原则

- 单条条件语法错误：应被捕获并降级为“该条件永不命中”，同时输出可诊断信息。
- 运行时异常：应隔离（不影响其他模块），并可通过调试命令查询。

---

## 6. 决策引擎与预测机制

### 6.1 决策循环

- 输入：当前帧的状态快照（Context）。
- 过程：遍历 APL → 命中动作 → 计算动作可用性（CD/GCD/资源/目标约束）。
- 输出：推荐动作（以及可选的“预测动作”）。

### 6.2 虚拟时间预测

- 预测的核心是“在不影响真实状态的前提下推进一个虚拟状态”。
- 虚拟推进应覆盖：GCD 推进、资源自然回复、Buff/Debuff 剩余时间衰减、读条完成。
- 预测结果用于 UI 的次要高亮与提示，不改变主要决策。

### 6.3 动作到槽位的映射

- 推荐的输出单位是“动作”，展示单位是“槽位/键位”。
- 映射规则允许：一个动作对应多个槽位；优先选择玩家当前可用且可见的槽位。

---

## 7. UI 与交互设计

### 7.1 网格 UI

- 核心交互：以网格表达“键位布局”，高亮网格而非展示技能图标队列。
- 高亮层级：
  - 主要高亮：当前推荐动作。
  - 次要高亮：预测动作（可选）。
- 稳定性：避免高亮状态在同一动作连续帧中反复重启动画。

### 7.2 配置面板

- APL 编辑：提供多行文本编辑与基础语法反馈。
- Layout 编辑：支持拖拽绑定/交换、预览高亮。
- 导入/导出：以字符串方式进行（可粘贴、可分享）。

### 7.3 音频提示

- 与视觉提示解耦：音频是可选输出通道。
- 去抖/节流：避免同一动作在短时间内重复播报。

---

## 8. 配置体系与配置交换

### 8.1 配置类型与优先级

- 内置配置：随插件分发，用作默认体验与参考模板。
- 用户配置：从导入或编辑产生；与角色/专精/版本信息关联。
- 优先级：用户配置覆盖内置配置。

### 8.2 配置结构（概念）

- Meta：职业、专精、版本、来源类型、可选的作者/描述。
- Layout：槽位布局与动作映射。
- APL：优先级列表文本。

### 8.3 导入/导出机制

- 导出：结构化配置 → 序列化 → 压缩 → 编码为字符串。
- 导入：字符串 → 解码/解压 → 结构校验 → 写入保存 → 重新编译。

---

## 9. 性能、可靠性与可观测性

### 9.1 性能策略

- **按需状态获取**：通过 `State` 模块的元表机制，避免在每一帧全量扫描所有技能和 Buff，仅获取当前决策逻辑关心的数据。
- **事件节流**：`EventHandler` 对非高优先级的战斗日志事件进行队列缓存和节流处理，合并 UI 更新请求。
- **脚本缓存**：`SimCParser` 维护编译后脚本的缓存统计（Hits/Misses），确保运行时开销最小化。
- **对象池**：复用临时对象，降低 GC 压力。

### 9.2 可靠性与隔离

- 沙盒原则：用户可编辑内容的执行路径必须被保护（例如错误隔离与超时告警）。
- 失败降级：任何模块异常应退化为“不输出推荐/仅输出基础提示”，而非报错中断。

### 9.3 可观测性（调试与统计）

- 命令行能力：
  - `/wam debug`：输出调试信息。
  - `/wam state`：输出状态快照摘要。
  - `/wam eval <条件>`：对单条条件进行解释与测试。
  - `/wam profile`：输出模块耗时、帧统计、缓存命中率等。

---

## 10. 兼容性与本地化

### 10.1 平台兼容

- 目标平台为 WotLK 3.3.5a，不同服务器可能存在 API 行为差异。
- 光环扫描需处理返回值差异与 Buff 槽位上限。

### 10.2 多语言与稳定标识

- 优先使用 SpellID 作为稳定标识（技能名可能因本地化或服务器数据不同而变化）。

---

## 11. 附录

### 11.1 参考资料

- [SimulationCraft APL](https://github.com/simulationcraft/simc/wiki/ActionLists)
- [Hekili 源码](https://github.com/Hekili/hekili)
- [WoW API (WotLK)](https://wowpedia.fandom.com/wiki/World_of_Warcraft_API)
- [LibCustomGlow](https://www.curseforge.com/wow/addons/libcustomglow)

---

**文档版本**: 2.1  
**最后更新**: 2026-01-22
